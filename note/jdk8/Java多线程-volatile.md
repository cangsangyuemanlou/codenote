# volatile

## 内存模型

内存 - 高速缓存 - CPU

在多线程下，同一资源，由于线程缓存/CPU缓存，可能存在缓存不一致的问题。



## 并发编程的三个概念

- 原子性
- 可见性
- 有序性

### 1 原子性问题

要么全部执行，要么全部不执行。

### 2 可见性问题

当多个线程访问同一个变量，如果其中一个线程修改了，其他线程能否立即感知到。

### 3 有序性问题

程序的执行顺序按照代码的先后顺序执行。

指令重排序：处理器对代码进行优化，不保证程序中各个语句的执行顺序与书写顺序，但是保证程序最终执行的结果的一致。没有数据依赖关系的语句可能会进行重排序。

指令重排序，不会影响单个线程的执行结果，但是会影响并发情况下的正确性。



## Java内存模型

Java所有的变量都存在主存中。

Java线程有自己的工作内存。

1 原子性

int等基本类型的读取和赋值是原子的，大部分都不是原子的，可通过synchronized和Lock来实现原子。

2 可见性

volatile可保证可见性。

共享变量被volatile修饰时，可保证修改的值立即更新到主存，其他线程都从主存中读取。

synchronized和Lock也可保证可见性，因为在释放锁之前，会将所有变量刷新到主存。

3 有序性

volatile可保证一定的有序性。

synchronized和Lock内部是单线程运行，可以保证有序性。

happens-before原则



## volatile

语义：

1 保证不同线程对这个变量的操作的可见性，立即可见

2 禁止指令重排



### 不保证原子性

修饰变量，保证读取的是最新值，但是无法保证对变量的操作是原子的。

### 保证可见性

就是为了保证可见性

### 一定程度上保证有序性

程序执行到volatile变量时，前面的操作一定执行完了，后面的操作一定还没执行。

进行指令重排时，不能将volatile变量前后的顺序交换位置。



